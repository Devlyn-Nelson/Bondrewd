impl ReallyHardcore {# [inline] # [doc = "Reads bits 0 through 7 within `input_byte_buffer`, getting the `three` field of a `ReallyHardcore` in bitfield form."] pub fn read_three (input_byte_buffer : & [u8 ; 2usize]) -> OtherQuarter {OtherQuarter :: from_bytes ({([((input_byte_buffer [1usize] & 255u8)) << 0usize])})} # [inline] # [doc = "Returns the value for the `three` field of a `ReallyHardcore` in bitfield form by reading  bits 0 through 7 in `input_byte_buffer`. Otherwise a [BitfieldLengthError](bondrewd::BitfieldLengthError) will be returned if not enough bytes are present."] pub fn read_slice_three (input_byte_buffer : & [u8]) -> Result < OtherQuarter , bondrewd :: BitfieldLengthError > {let slice_length = input_byte_buffer . len () ; if slice_length < 2usize {Err (bondrewd :: BitfieldLengthError (slice_length , 2usize))} else {Ok (OtherQuarter :: from_bytes ({([((input_byte_buffer [1usize] & 255u8)) << 0usize])}))}} # [inline] # [doc = "Reads bits 8 through 11 within `input_byte_buffer`, getting the `two` field of a `ReallyHardcore` in bitfield form."] pub fn read_two (input_byte_buffer : & [u8 ; 2usize]) -> OneQuarter {OneQuarter :: from_bytes ({([((input_byte_buffer [0usize] & 240u8)) << 0usize])})} # [inline] # [doc = "Returns the value for the `two` field of a `ReallyHardcore` in bitfield form by reading  bits 8 through 11 in `input_byte_buffer`. Otherwise a [BitfieldLengthError](bondrewd::BitfieldLengthError) will be returned if not enough bytes are present."] pub fn read_slice_two (input_byte_buffer : & [u8]) -> Result < OneQuarter , bondrewd :: BitfieldLengthError > {let slice_length = input_byte_buffer . len () ; if slice_length < 1usize {Err (bondrewd :: BitfieldLengthError (slice_length , 1usize))} else {Ok (OneQuarter :: from_bytes ({([((input_byte_buffer [0usize] & 240u8)) << 0usize])}))}} # [inline] # [doc = "Reads bits 12 through 15 within `input_byte_buffer`, getting the `one` field of a `ReallyHardcore` in bitfield form."] pub fn read_one (input_byte_buffer : & [u8 ; 2usize]) -> OneHalf {OneHalf :: from_bytes ({([((input_byte_buffer [0usize] & 15u8)) << 4usize])})} # [inline] # [doc = "Returns the value for the `one` field of a `ReallyHardcore` in bitfield form by reading  bits 12 through 15 in `input_byte_buffer`. Otherwise a [BitfieldLengthError](bondrewd::BitfieldLengthError) will be returned if not enough bytes are present."] pub fn read_slice_one (input_byte_buffer : & [u8]) -> Result < OneHalf , bondrewd :: BitfieldLengthError > {let slice_length = input_byte_buffer . len () ; if slice_length < 1usize {Err (bondrewd :: BitfieldLengthError (slice_length , 1usize))} else {Ok (OneHalf :: from_bytes ({([((input_byte_buffer [0usize] & 15u8)) << 4usize])}))}} # [doc = "Returns a [ReallyHardcoreChecked] which allows you to read any field for a `ReallyHardcore` from provided slice."] pub fn check_slice (buffer : & [u8]) -> Result < ReallyHardcoreChecked , bondrewd :: BitfieldLengthError > {let buf_len = buffer . len () ; if buf_len >= 2usize {Ok (ReallyHardcoreChecked {buffer})} else {Err (bondrewd :: BitfieldLengthError (buf_len , 2usize))}} # [inline] # [doc = "Writes to bits 0 through 7 within `output_byte_buffer`, setting the `three` field of a `ReallyHardcore` in bitfield form."] pub fn write_three (output_byte_buffer : & mut [u8 ; 2usize] , mut three : OtherQuarter) {output_byte_buffer [1usize] &= 0u8 ; output_byte_buffer [1usize] |= (three . into_bytes () [0]) >> 0usize ;} # [inline] # [doc = "Writes to bits 0 through 7 in `input_byte_buffer` if enough bytes are present in slice, setting the `three` field of a `ReallyHardcore` in bitfield form. Otherwise a [BitfieldLengthError](bondrewd::BitfieldLengthError) will be returned"] pub fn write_slice_three (output_byte_buffer : & mut [u8] , three : OtherQuarter) -> Result < () , bondrewd :: BitfieldLengthError > {let slice_length = output_byte_buffer . len () ; if slice_length < 2usize {Err (bondrewd :: BitfieldLengthError (slice_length , 2usize))} else {output_byte_buffer [1usize] &= 0u8 ; output_byte_buffer [1usize] |= (three . into_bytes () [0]) >> 0usize ; Ok (())}} # [inline] # [doc = "Writes to bits 8 through 11 within `output_byte_buffer`, setting the `two` field of a `ReallyHardcore` in bitfield form."] pub fn write_two (output_byte_buffer : & mut [u8 ; 2usize] , mut two : OneQuarter) {output_byte_buffer [0usize] &= 15u8 ; output_byte_buffer [0usize] |= (two . into_bytes () [0]) >> 0usize ;} # [inline] # [doc = "Writes to bits 8 through 11 in `input_byte_buffer` if enough bytes are present in slice, setting the `two` field of a `ReallyHardcore` in bitfield form. Otherwise a [BitfieldLengthError](bondrewd::BitfieldLengthError) will be returned"] pub fn write_slice_two (output_byte_buffer : & mut [u8] , two : OneQuarter) -> Result < () , bondrewd :: BitfieldLengthError > {let slice_length = output_byte_buffer . len () ; if slice_length < 1usize {Err (bondrewd :: BitfieldLengthError (slice_length , 1usize))} else {output_byte_buffer [0usize] &= 15u8 ; output_byte_buffer [0usize] |= (two . into_bytes () [0]) >> 0usize ; Ok (())}} # [inline] # [doc = "Writes to bits 12 through 15 within `output_byte_buffer`, setting the `one` field of a `ReallyHardcore` in bitfield form."] pub fn write_one (output_byte_buffer : & mut [u8 ; 2usize] , mut one : OneHalf) {output_byte_buffer [0usize] &= 240u8 ; output_byte_buffer [0usize] |= (one . into_bytes () [0]) >> 4usize ;} # [inline] # [doc = "Writes to bits 12 through 15 in `input_byte_buffer` if enough bytes are present in slice, setting the `one` field of a `ReallyHardcore` in bitfield form. Otherwise a [BitfieldLengthError](bondrewd::BitfieldLengthError) will be returned"] pub fn write_slice_one (output_byte_buffer : & mut [u8] , one : OneHalf) -> Result < () , bondrewd :: BitfieldLengthError > {let slice_length = output_byte_buffer . len () ; if slice_length < 1usize {Err (bondrewd :: BitfieldLengthError (slice_length , 1usize))} else {output_byte_buffer [0usize] &= 240u8 ; output_byte_buffer [0usize] |= (one . into_bytes () [0]) >> 4usize ; Ok (())}} # [doc = "Returns a [ReallyHardcoreCheckedMut] which allows you to read/write any field for a `ReallyHardcore` from/to provided mutable slice."] pub fn check_slice_mut (buffer : & mut [u8]) -> Result < ReallyHardcoreCheckedMut , bondrewd :: BitfieldLengthError > {let buf_len = buffer . len () ; if buf_len >= 2usize {Ok (ReallyHardcoreCheckedMut {buffer})} else {Err (bondrewd :: BitfieldLengthError (buf_len , 2usize))}}} impl bondrewd :: Bitfields < 2usize > for ReallyHardcore {const BIT_SIZE : usize = 16usize ; fn from_bytes (mut input_byte_buffer : [u8 ; 2usize]) -> Self {let three = OtherQuarter :: from_bytes ({([((input_byte_buffer [1usize] & 255u8)) << 0usize])}) ; let two = OneQuarter :: from_bytes ({([((input_byte_buffer [0usize] & 240u8)) << 0usize])}) ; let one = OneHalf :: from_bytes ({([((input_byte_buffer [0usize] & 15u8)) << 4usize])}) ; Self {one , two , three ,}} fn into_bytes (self) -> [u8 ; 2usize] {let mut output_byte_buffer : [u8 ; 2usize] = [0u8 ; 2usize] ; let three = self . three ; output_byte_buffer [1usize] |= (three . into_bytes () [0]) >> 0usize ; let two = self . two ; output_byte_buffer [0usize] |= (two . into_bytes () [0]) >> 0usize ; let one = self . one ; output_byte_buffer [0usize] |= (one . into_bytes () [0]) >> 4usize ; output_byte_buffer}} impl bondrewd :: BitfieldHex < 4usize , 2usize > for ReallyHardcore {} impl bondrewd :: BitfieldHexDyn < 4usize , 2usize > for ReallyHardcore {} # [doc = "A Structure which provides functions for getting the fields of a [ReallyHardcore] in its bitfield form."] pub struct ReallyHardcoreChecked < 'a > {buffer : & 'a [u8] ,} impl < 'a > ReallyHardcoreChecked < 'a > {# [inline] # [doc = "Reads bits 0 through 7 in pre-checked slice, getting the `three` field of a [ReallyHardcore] in bitfield form."] pub fn read_three (& self) -> OtherQuarter {let input_byte_buffer : & [u8] = self . buffer ; OtherQuarter :: from_bytes ({([((input_byte_buffer [1usize] & 255u8)) << 0usize])})} # [inline] # [doc = "Reads bits 8 through 11 in pre-checked slice, getting the `two` field of a [ReallyHardcore] in bitfield form."] pub fn read_two (& self) -> OneQuarter {let input_byte_buffer : & [u8] = self . buffer ; OneQuarter :: from_bytes ({([((input_byte_buffer [0usize] & 240u8)) << 0usize])})} # [inline] # [doc = "Reads bits 12 through 15 in pre-checked slice, getting the `one` field of a [ReallyHardcore] in bitfield form."] pub fn read_one (& self) -> OneHalf {let input_byte_buffer : & [u8] = self . buffer ; OneHalf :: from_bytes ({([((input_byte_buffer [0usize] & 15u8)) << 4usize])})} # [doc = "Panics if resulting `ReallyHardcoreChecked` does not contain enough bytes to read a field that is attempted to be read."] pub fn from_unchecked_slice (data : & 'a [u8]) -> Self {Self {buffer : data}}} # [doc = "A Structure which provides functions for getting and setting the fields of a [ReallyHardcore] in its bitfield form."] pub struct ReallyHardcoreCheckedMut < 'a > {buffer : & 'a mut [u8] ,} impl < 'a > ReallyHardcoreCheckedMut < 'a > {# [inline] # [doc = "Reads bits 0 through 7 in pre-checked slice, getting the `three` field of a [ReallyHardcore] in bitfield form."] pub fn read_three (& self) -> OtherQuarter {let input_byte_buffer : & [u8] = self . buffer ; OtherQuarter :: from_bytes ({([((input_byte_buffer [1usize] & 255u8)) << 0usize])})} # [inline] # [doc = "Reads bits 8 through 11 in pre-checked slice, getting the `two` field of a [ReallyHardcore] in bitfield form."] pub fn read_two (& self) -> OneQuarter {let input_byte_buffer : & [u8] = self . buffer ; OneQuarter :: from_bytes ({([((input_byte_buffer [0usize] & 240u8)) << 0usize])})} # [inline] # [doc = "Reads bits 12 through 15 in pre-checked slice, getting the `one` field of a [ReallyHardcore] in bitfield form."] pub fn read_one (& self) -> OneHalf {let input_byte_buffer : & [u8] = self . buffer ; OneHalf :: from_bytes ({([((input_byte_buffer [0usize] & 15u8)) << 4usize])})} # [inline] # [doc = "Writes to bits 0 through 7 in pre-checked mutable slice, setting the `three` field of a [ReallyHardcore] in bitfield form."] pub fn write_three (& mut self , three : OtherQuarter) {let output_byte_buffer : & mut [u8] = self . buffer ; output_byte_buffer [1usize] &= 0u8 ; output_byte_buffer [1usize] |= (three . into_bytes () [0]) >> 0usize ;} # [inline] # [doc = "Writes to bits 8 through 11 in pre-checked mutable slice, setting the `two` field of a [ReallyHardcore] in bitfield form."] pub fn write_two (& mut self , two : OneQuarter) {let output_byte_buffer : & mut [u8] = self . buffer ; output_byte_buffer [0usize] &= 15u8 ; output_byte_buffer [0usize] |= (two . into_bytes () [0]) >> 0usize ;} # [inline] # [doc = "Writes to bits 12 through 15 in pre-checked mutable slice, setting the `one` field of a [ReallyHardcore] in bitfield form."] pub fn write_one (& mut self , one : OneHalf) {let output_byte_buffer : & mut [u8] = self . buffer ; output_byte_buffer [0usize] &= 240u8 ; output_byte_buffer [0usize] |= (one . into_bytes () [0]) >> 4usize ;} # [doc = "Panics if resulting `ReallyHardcoreCheckedMut` does not contain enough bytes to read a field that is attempted to be read or written."] pub fn from_unchecked_slice (data : & 'a mut [u8]) -> Self {Self {buffer : data}}} impl bondrewd :: BitfieldsDyn < 2usize > for ReallyHardcore {# [doc = "Creates a new instance of `Self` by copying field from the bitfields. \n # Errors\n If the provided `Vec<u8>` does not have enough bytes an error will be returned."] fn from_slice (input_byte_buffer : & [u8]) -> Result < Self , bondrewd :: BitfieldLengthError > {if input_byte_buffer . len () < Self :: BYTE_SIZE {return Err (bondrewd :: BitfieldLengthError (input_byte_buffer . len () , Self :: BYTE_SIZE)) ;} let out = {let three = OtherQuarter :: from_bytes ({([((input_byte_buffer [1usize] & 255u8)) << 0usize])}) ; let two = OneQuarter :: from_bytes ({([((input_byte_buffer [0usize] & 240u8)) << 0usize])}) ; let one = OneHalf :: from_bytes ({([((input_byte_buffer [0usize] & 15u8)) << 4usize])}) ; Self {one , two , three ,}} ; Ok (out)} # [doc = "Creates a new instance of `Self` by copying field from the bitfields, removing bytes that where used. \n # Errors\n If the provided `Vec<u8>` does not have enough bytes an error will be returned."] fn from_vec (input_byte_buffer : & mut Vec < u8 >) -> Result < Self , bondrewd :: BitfieldLengthError > {if input_byte_buffer . len () < Self :: BYTE_SIZE {return Err (bondrewd :: BitfieldLengthError (input_byte_buffer . len () , Self :: BYTE_SIZE)) ;} let out = {let three = OtherQuarter :: from_bytes ({([((input_byte_buffer [1usize] & 255u8)) << 0usize])}) ; let two = OneQuarter :: from_bytes ({([((input_byte_buffer [0usize] & 240u8)) << 0usize])}) ; let one = OneHalf :: from_bytes ({([((input_byte_buffer [0usize] & 15u8)) << 4usize])}) ; Self {one , two , three ,}} ; let _ = input_byte_buffer . drain (.. Self :: BYTE_SIZE) ; Ok (out)}}